---
title: COMP 1020
author: Franklin Bristow
date: 2020
header-includes:
    \usepackage{fullpage}
toccolor: blue
---

Course prerequisites {-}
====================

Before entering this course, a student should have completed COMP 101{0,1,2,3}
and should be able to:

* Write and run moderately complex programs using a procedural programming
  language. :program:
* Read and evaluate written programs. :evaluate:
* Describe basic programming concepts and structures in plain English.
  :communicate:
* Represent ideas and information in a way that computers can understand and act
  on. :represent:
* Analyze and implement basic searching algorithms. :algorithms:

Course outcomes {-}
===============

By the end of this course, a student should be able to:

1. Use classes, objects, and inheritance effectively to design and implement
   structured representation of information. :oo:
2. Begin to design software using non-OO principles. :design:
3. Begin to evaluate software behaviour. :testing:
4. Write code that can handle failures gracefully. :exceptions:
5. Write software that deals with large sets of data using files stored on disk.
   :files:
6. Apply searching and sorting algorithms to collections, compare efficiency. :algorithms:
7. Use and implement data structures to solve a problem. :data-structures:
8. Formulate recursive solutions to problems, and write recursive methods.
   :recursion:

Learning objectives {-}
===================

Course introduction, real Java
------------------------------

By the end of this unit, students should be able to:

1. Write and run a program in a *new* programming language (Java), transferring
   skills learned in previous courses (Python or Processing).
   :program#first-year-review:
   
**Note**: In the current curriculum, this unit is 2 weeks long.

OOP Basics 1
------------

By the end of this unit, students should be able to:

1. Define the term "Object-oriented programming". :oo#overview-of-oo:
   :communicate#explain-basic-oo-concepts:
    1. List the properties of a class.
    2. Explain what the `this` keyword represents in an instance method of a
       class.
    3. Define the term "encapsulation".
    4. Explain how and why the concept of encapsulation is useful.
    5. Explain how access modifiers (e.g., `public` and `private`) enable you to
       apply the principle of encapsulation.
2. Decide if an instance method or instance variable can be invoked or used in a
   specific scope given its access modifier. :oo#method-overloading:
   :evaluate#evaluate-method-overloading:
3. Declare, initialize, and use instances of a *user-defined* class.
   :oo#apply-basic-oo-concepts: :program#create-and-use-a-class:
    1. Write a "default constructor" for a class.
    2. Write and call instance methods for a class (e.g., `toString`,
       `compareTo`).
    3. Choose an appropriate access modifier for parts of a class (i.e., decide
       if data or code should be `public` or `private`).
    4. Decide if accessors and mutators are necessary for an instance variable
       (i.e., is the data part of the public interface of the class?). 
       
       
OOP Basics 2
------------

By the end of this unit, students should be able to:

1. Write a method to copy an instance of an object. :oo#copy-constructor:
   :program#write-a-copy-constructor:
    1. Decide when to use a shallow copy vs a deep copy.
2. Compare and contrast a "shallow copy" (i.e., use of assignment operator on a
   reference) vs "deep copy" (i.e., use of copy constructors or methods to copy
   object data). :oo#pointers-vs-primitives:
   :communicate#explain-differences-between-pointers-and-primitives:
    1. Given a piece of code, draw a diagram that shows the state of references
       and copies as the code executes (passing-by-value vs
       passing-by-reference).
3. Explain what happens when an instance of an object has no references to it in
   Java (i.e., garbage collection).
   :communicate#basic-explain-garbage-collection:
4. Compose a class from several other classes by declaring instance variables
   using other user-defined types (e.g., a `Person` has an `Address`).
   :design#compose-objects-with-objects: :program#write-composite-classes:
5. Declare a class that refers to itself with instance variables (e.g., a
   `Person` has other `Person` attributes, like parents).
   :oo#self-referencing-classes: :program#write-self-referencing-classes:
6. Write and use a "list" class to represent a collection of values.
   :data-structures#lists-for-collections: :program#write-a-list-class:
7. Explain how using a "list" class can be better than using an array to
   represent collections of values. :data-structures#properties-of-lists:
   :communicate#list-differences-between-list-and-array:
   
Multi-dimensional arrays
------------------------

By the end of this unit, students should be able to:

1. Declare, initialize, and use multi-dimensional arrays in a Java program.
   :data-structures#multidimensional-data:
   :program#create-and-use-multidimensional-arrays:
    1. Declare, initialize, and use "ragged" arrays in a Java program (i.e.,
       multi-dimensional arrays with non-uniform length in the 2^nd^+
       dimension).
    2. Write a class that has a multi-dimensional array as an instance variable.
2. Given a piece of code, draw a diagram representing the state of references in
   a multi-dimensional array.
   :data-structures#multidimensional-arrays-with-references:
   :communicate#describe-mental-model-of-data:
3. Create "useful" instance methods for a class. [^useful-methods]
   :design#identify-common-operations: :program#write-instance-methods:
4. Write a simple, manual testing method for a class, in a separate file.
   :testing#automated-testing: :program#multi-file-compilation:

[^useful-methods]: In the context of this course, a "useful" instance method is
one that provides matrix operations on a class that contains a multi-dimensional
array. I think the *intention* of this objective is that students be able to
generally lift reasonable operations on the object to its interface, but the
course only demonstrates this as writing operations on a matrix.

File I/O and exceptions
-----------------------

By the end of this unit, students should be able to:

1. Create and use/`throw`/`catch` an `Exception` in a program.
   :exceptions#indicating-exceptional-behaviour:
   :program#create-and-use-exceptions:
    1. Use built-in Java `Exception` types.
    2. Create user-defined `Exception` types.
2. Handle exceptions thrown (`try`/`catch`) by library code (specifically: I/O).
   :exceptions#handling-exceptional-behaviour: :files#read-from-a-file:
   :program#write-code-to-read-files-handle-exceptions:
    1. Decide if an `Exception` should be handled in a `try`/`catch` block, or
       should be `throw`n by marking a method with `throws`.
    2. Handle *specific* `Exception`s thrown by an operation.
3. List the order of operations in a `try`/`catch`/`finally` block, given a
   piece of code. :exceptions#finally-block: :evaluate#list-order-of-exception-handling-code:
4. Read and write text files in a program. :files#files-as-objects:
   :program#read-and-write-files:
5. Parse the contents of a file by tokenizing strings in a program (e.g.,
   `String#split` or `Scanner`). :files#tokenizing-strings:
   :program#write-code-to-tokenize-strings:
    1. Create an instance of a class based on the data that's contained within a
       file.
   
   
OOP Polymorphism 1
------------------

By the end of this unit, students should be able to:

1. Create and use a subclass in a Java program. :oo#class-hierarchies:
   :program#create-and-use-subclasses:
    1. Write one or more non-default constructors in a class hierarchy.
    2. Call the constructor or method in the parent class with the `super`
       keyword.
    3. Override the behaviour of a superclass in a subclass.
    4. Use the `protected` modifier to share data and behaviour between parent
       and subclass.
2. Given a class and subclass that have properties or behaviour with the same
   name (instance variables or method signatures), determine which property is
   being referred to in a specific scope. :oo#scoping-and-class-hierarchies:
   :evaluate#decide-which-property-is-referred-to-in-scope:
3. Use implicit and explicit typecasting to broaden or narrow the type of a
   value. :oo#casting-rules-for-classes: :program#upcast-and-downcast-instances:
    1. Safely cast between types using the `instanceof` operator.
4. Define the term "polymorphism". :oo#polymorphism-and-oo:
   :communicate#define-polymorphism:
    1. Explain how polymorphism is related to `abstract` classes in Java.
5. Write code that implements the concept of polymorphism in Java.
   :oo#apply-polymorphism: :program#write-polymorphic-abstract-class:
    1. Write an `abstract` class in a Java program.

OOP Polymorphism 2 
------------------

By the end of this unit, students should be able to:

1. Decompose a real-world domain into a model represented as a hierarchy of
   related classes. :oo#real-world-hierarchies:
   :design#design-a-hierarchy-before-use:
    1. Decide which class in a hierarchy of classes should have a property or
       behaviour.
2. Draw a diagram representing related classes in a hierarchy.
   :oo#hierarchies-as-tree: :communicate#describe-mental-model-of-hierarchy:

Strings[^strings], ArrayLists
-------------------

By the end of this unit, students should be able to:

1. Create and use instances of the Java-specific `ArrayList` class.
   :data-structures#array-as-list-data-structure:
   :program#use-language-library-data-structures:
    1. Use the "generics" feature in Java to hint about the type stored in the
       collection.
    2. Use Java-specific wrapper classes for primitive types (i.e., `int` cannot
       be stored in a generic `ArrayList`, but `Integer` can).
2. Compare and contrast arrays and `ArrayList` (or, more generally, the `List`
   interface). :data-structures#data-structure-comparisons:
   :communicate#explain-differences-between-data-structures:
   
[^strings]: The only learning objective related to `String`s in this unit is to be
able to list/memorize and use *more* `String` methods.

Linked Lists
------------

By the end of this unit, students should be able to:

1. Compare and contrast lists and arrays (e.g., insertion/deletion time, access
   time, contiguous memory allocation, size restrictions, etc).
   :data-structures#properties-of-data-structures:
   :communicate#compare-data-structures:
2. Create and use a linked list data structure in a program.
   :data-structures#linked-list-data-structure:
   :program#create-and-use-linked-list-class:
    1. Write a method to add a node to the top of a linked list.
    2. Write a method to iterate over the nodes in a linked list.
    3. Write a method to insert a node in an arbitrary position in a linked
       list.
    4. Write a method to delete a node from a linked list data structure by key
       or index.
    5. Write a method to do an ordered insertion of a node into a linked list.
3. Given a description of some data, decide which of a list or an array is the
   best choice for data structure.
   :data-structures#flexibility-of-data-structures:
   :design#choose-a-reasonable-data-structure:

Recursion
---------

By the end of this unit, students should be able to:

1. Write a recursive program that implements a recursive algorithm (e.g.,
   factorial, Fibonacci), given the algorithm.
   :recursion#recurrence-relations-to-programs:
   :program#write-recursive-code-given-algorithm:
2. Draw a diagram representing the state of a stack of method calls in a
   recursive function. :recursion#recursion-as-a-stack:
   :communicate#describe-mental-model-of-recursion:
3. Create and implement recursive solution to a simple problem (e.g.,
   permutations of a sequence, all subsets of a sequence).
   :recursion#derive-recursion-from-problem:
   :design#design-recursive-solution-to-problem:
   :program#implement-recursion-with-helpers:
    1. Write a recursive solution to a problem with a "helper" function.
4. Give an example of when recursion is not an appropriate solution to a
   problem, and explain why. :recursion#recursion-isn't-perfect:
   :communicate#explain-limitations-of-recursion:
   
Searching[^searching] and sorting
---------------------------------

By the end of this unit, students should be able to:

1. Give examples of search algorithms for sequences of data.
   :algorithms#searching-algorithms: :communicate#list-searching-algorithms:
2. Compare and contrast linear search and binary search.
   :algorithms#complexity-and-data-requirements:
   :communicate#compare-searching-algorithms:
    1. List the data requirements for binary search to be applied (e.g.,
       ordered, contiguous memory).
    2. List the runtime requirements of binary search and linear search, in
       big-O notation.
3. Given some data, decide if linear search or binary search should be applied.
   :algorithms#data-guides-algorithm-choice:
   :design#choose-an-algorithm-based-on-data:
4. Write a program that implements linear search and binary search on an array.
   :algorithms#apply-searching-algorithms-to-arrays:
   :program#write-binary-and-linear-search:
5. Write a program that implements binary search *recursively* on an array.
   :algorithms#convert-algorithms-sequential-to-recursive:
   :recursion#derive-recursive-solution-to-linear-algorithm:
   :program#write-recursive-search-functions:
6. Describe sorting algorithms (e.g., insertion sort, selection sort, recursive
   merge sort, quick sort) in plain English. :algorithms#sorting-algorithms:
   :communicate#describe-basic-sorting-algorithms:
7. Compare and contrast sorting algorithms (e.g., insertion sort, selection
   sort, recursive merge sort, quick sort).
   :algorithms#complexity-of-sorting-algorithms:
   :communicate#compare-sorting-algorithms:
    1. List the runtime requirements of different sorting algorithms.
    2. Explain why choosing a poor pivot reduces the overall performance of the
       quick sort algorithm.
8. Write a program to implement sorting algorithms (e.g., insertion sort,
   selection sort, recursive merge sort, quick sort).
   :algorithms#implementation-details-of-sorting-algorithms:
   :program#write-sorting-alrogithms:

[^searching]: Both linear search and binary search are learning objectives that
listed in COMP 1010.
