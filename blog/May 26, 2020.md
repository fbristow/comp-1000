Things to do:

* [X] Section titles
* [o] Section summaries
    * [X] Points
    * [ ] Single paragraph/sentence.

---

I want to come up with some section titles and brief summaries of what would be
covered in the section. Trying to merge two courses, then massage them into what
I want isn't working the way I had hoped.

I want the section titles that I come up with should have some kind of a
narrative --- I don't want to have this become a topics course with a bunch of
unrelated things getting stuck together.

I also want my course to follow through with my true intention: show students
what computer science can be, then a tour of how we got to where we are, *then*
programming and programming concepts.

I think I'm still pretty keen on keeping COMP 1500 (as I delivered it) intact.


Part 1
------

Part 1 focuses on helping students decide if they want to pursue computer
science, and which discipline within computer science is what they want to
pursue, then approaches computing from first principles all the way up to a real
programming project.

1. Computer science: What even is it? Who even are computer scientists?
    * Our first survey of CS as a field.
    * Basically: Is CS what you even want?
2. What even is a computer?
    * Hint: It's *not* smart. Let's take a high-level look at computers.
    * What can they even *do*?
3. How do you represent *stuff*?
    * Computers are dumb, how do I give it something to work on? How do I tell
      it what to do? How do computers talk to each other?
4. Computer science: Where did it even come from?
    * Introduction to basic logic and arithmetic with logic. 
    * Turing machines?
    * International influences (this isn't all Europe and US).
5. Computer science: What do you even mean by "computer"?
    * Circuits and digital logic.
    * Full and half adders.
    * General purpose computing: CPUs, ALUs, memory (von Neumann Architecture).
6. Computer science: PROGRAMMING!
    * We've got this neato machine, how do we tell it what to do?
7. Computer science: Writing instructions?
    * Algorithms (searching and sorting).
8. Computer science: Writing *real* software.
    * That assembly language we learned earlier: not real, and not ideal.
    * How do we tell a *real* computer what to do?

Part 2
------

Part 2 focuses on sharpening programming skills. Now that you know what computer
science is, and which fields you're most interested in, you need to be able to
communicate with computers so that you can apply the skills you'll gain in later
years.

1. Your first *real* programming language.
    * Get some experience writing, compiling, and running code in
      Java/Python/Processing.
    * Your first taste of a real IDE.
2. Searching and sorting algorithms.
    * You saw searching and sorting as abstract algorithms. How can we use what
      we've learned about programming to 1) represent information, and 2) search
      and sort that information?
    * Arrays.
    * Your first taste of translating abstract concepts into real code.
4. Representing **complex** information.
    * The whole world isn't just numbers. How do we represent *things*?
    * Combining data and behaviour with classes.
    * Complex relationships between data (class composition and basic
      inheritance).
5. Getting **bulk** information.
    * Typing in data is not realistic, we need to be able to get *lots* of data,
      so let's work with files.
6. Data structures, ADTs, and software design
    * Now that we've got bulk data, we need to be able to store a *collection*
      of things. Arrays are great, but limited. How can we represent complex
      collections of information?
    * Lists, lists, lists!
    * Interfaces and implementations.
7. Recursion.
    * Here's where my narrative falls apart.
    * We could do list processing with loops, or this fancy tool called
      "recursion".
