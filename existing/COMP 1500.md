COMP 1500
=========

Calendar entry:

> An introduction to the topics of Computer Science and problem solving.
> Students will learn concepts in computer programming.

Sources of information
----------------------

* Jim's COMP 1500 textbook
* Me
* Gord Boyer (taught in Fall 2019)
* Al Marshall (currently teaching)

Tasks
-----

* [ ] Extract learning outcomes from own slides
* [ ] Confirm learning outcomes from Jim's course
* [ ] Contact Gord

Course objectives
-----------------

COMP 1500 is more tricky to nail down with course objectives that go beyond the
calendar entry. The original idea with COMP 1500 is that the individual
instructor could add their own personal interpretation for what computer science
is.

With that in mind, here are the course objectives from when I taught the course
with Gord:

* Learn how computer science is not just computer programming.
* Represent information digitally.
* Learn how computers function, at a low level.
* Apply problem-solving skills.
* Use and evaluate algorithms.
* Implement abstractions as software.
* Apply computer science concepts to domain areas.

Learning outcomes
-----------------

### Introduction

* Explain what computer science is.
* Explain the etymology of the word "computer".
* Label all of the components of a Turing machine.
* Given a Turing machine and tape, evaluate the output of a Turing machine.
* Label all of the components of a von Neumann machine.
* Classify contemporary computer components to the von Neumann architecture.

### Representing information digitally

* Convert numbers between base systems.
* Explain how an image can be stored digitally.
* Explain how formats and encodings are important for communication.
* Predict how an animation might be stored digitally.

### How computers function

* Find errors in a circuit.
* Translate a plain-English problem into a flow diagram.
* Translate a boolean expression into a circuit.
* Predict the output of a circuit given specific inputs.
* Explain how a circuit can make a decision.
* Explain why abstractions are necessary to hide complexity.

### Apply problem-solving skills

* Define the term algorithm.
* Divide a big problem into smaller steps.
* Decide whether or not a computer can solve a problem.
* Explain how run-time complexity is used to measure the "goodness" of an
  algorithm.
* Rank searching algorithms by run-time complexity.
* Compare and contrast P and NP.

### Implement abstractions as software

* Find errors in a program in a simple programming language.
* Rewrite a plain-English solution as a program in a simple programming
  language.
  

